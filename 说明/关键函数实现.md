# 关键函数实现解析

## 1. 稀疏自编码器 (SAE)
```python
class SAE(nn.Module):
    def __init__(self, in_dim, hid=64, out_dim=32):
        super().__init__()
        self.enc = nn.Sequential(
            nn.Linear(in_dim, hid), 
            nn.ReLU(),
            nn.Linear(hid, out_dim)
        )
        self.dec = nn.Sequential(...)
    
    def forward(self, x):
        z = self.enc(x)  # 编码器
        xrec = self.dec(z)  # 解码器
        return z, xrec
```
- **功能**：特征压缩与重建
- **参数**：
  - `in_dim`: 输入特征维度
  - `hid`: 隐藏层维度
  - `out_dim`: 编码维度
- **数学原理**：
  $$
  z = f_{enc}(W_{enc}x + b_{enc}) \\
  \hat{x} = f_{dec}(W_{dec}z + b_{dec})
  $$

## 2. Transformer编码器
```python
class TransEncoder(nn.Module):
    def __init__(self, d_model, nhead, nlayers):
        layer = nn.TransformerEncoderLayer(
            d_model=d_model, nhead=nhead, batch_first=True)
        self.enc = nn.TransformerEncoder(layer, num_layers=nlayers)
    
    def forward(self, x):
        return self.enc(x)[:, -1, :]  # 取最后时间步
```
- **功能**：捕捉长期时序依赖
- **关键参数**：
  - `d_model`: 特征维度
  - `nhead`: 注意力头数
  - `nlayers`: 编码器层数
- **输出**：序列最后时间步的上下文表示

## 3. 分位数损失函数
```python
def pinball_loss(pred, target, qs=(0.1, 0.5, 0.9)):
    e = target - pred
    loss = 0.0
    for i, q in enumerate(qs):
        loss += torch.mean(torch.maximum(q * e[:, i], (q - 1) * e[:, i]))
    return loss / len(qs)
```
- **数学公式**：
  $$
  L_q = \frac{1}{N}\sum_{i=1}^{N} \begin{cases} 
  q(y_i - \hat{y}_i) & \text{if } y_i > \hat{y}_i \\
  (1-q)(\hat{y}_i - y_i) & \text{otherwise}
  \end{cases}
  $$
- **特性**：同时优化多个分位数预测

## 4. 保形预测校准
```python
def conformal_calibrate(q_lo, q_md, q_hi, y_true, tau=0.8):
    rad = np.maximum(q_md - q_lo, q_hi - q_md)
    miss = np.maximum(np.abs(y_true - q_md) - rad, 0.0)
    alpha = np.quantile(miss, tau)
    return alpha
```
- **作用**：校准预测区间覆盖率
- **参数**：
  - `tau`: 目标覆盖率(默认0.8)
- **输出**：校准系数alpha

## 5. SAETR前向传播
```python
def forward(self, x):
    z, xrec = self.sae(x)  # 特征编码
    if self.use_cnn:
        z = self.cnn(z.transpose(1,2)).transpose(1,2)  # CNN增强
    h = self.proj(z)  # 特征投影
    h = self.pos(h)  # 位置编码
    h_last = self.tr(h)[:, -1, :]  # Transformer编码
    q = self.head(h_last)  # 分位数预测
    return q, xrec, z
```
- **数据流**：
  原始输入 → SAE压缩 → CNN增强 → 投影 → 位置编码 → Transformer → 预测头